"""
Background Scanner API with Server-Sent Events (SSE)
Provides real-time push notifications for trade alerts
"""
from fastapi import APIRouter, HTTPException, Request
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime, timezone
import asyncio
import json
import logging

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/live-scanner", tags=["Live Scanner"])

# Service instance
_scanner = None


def init_live_scanner_router(scanner):
    """Initialize with scanner service"""
    global _scanner
    _scanner = scanner


# ===================== Models =====================

class WatchlistRequest(BaseModel):
    symbols: List[str] = Field(..., description="Symbols to watch")


class ConfigRequest(BaseModel):
    scan_interval: Optional[int] = Field(default=None, ge=30, le=300)
    enabled_setups: Optional[List[str]] = None


# ===================== SSE Endpoint =====================

@router.get("/stream")
async def stream_alerts(request: Request):
    """
    Server-Sent Events endpoint for real-time alert streaming.
    
    Connect to this endpoint to receive live alerts as they're generated.
    The scanner runs in the background and pushes alerts through this stream.
    
    Usage (JavaScript):
    ```
    const eventSource = new EventSource('/api/live-scanner/stream');
    eventSource.onmessage = (event) => {
        const alert = JSON.parse(event.data);
        console.log('New alert:', alert);
    };
    ```
    """
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    async def event_generator():
        queue = _scanner.subscribe()
        try:
            # Send initial connection message
            yield f"data: {json.dumps({'type': 'connected', 'timestamp': datetime.now(timezone.utc).isoformat()})}\n\n"
            
            # Send current alerts
            for alert in _scanner.get_live_alerts()[:5]:
                yield f"data: {json.dumps({'type': 'alert', 'alert': alert.to_dict()})}\n\n"
            
            # Stream new alerts
            while True:
                # Check if client disconnected
                if await request.is_disconnected():
                    break
                
                try:
                    # Wait for new alert with timeout
                    alert_data = await asyncio.wait_for(queue.get(), timeout=30)
                    yield f"data: {json.dumps({'type': 'alert', 'alert': alert_data})}\n\n"
                except asyncio.TimeoutError:
                    # Send keepalive
                    yield f"data: {json.dumps({'type': 'heartbeat', 'timestamp': datetime.now(timezone.utc).isoformat()})}\n\n"
                    
        except asyncio.CancelledError:
            pass
        finally:
            _scanner.unsubscribe(queue)
    
    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no"
        }
    )


# ===================== Scanner Control =====================

@router.post("/start")
async def start_scanner():
    """Start the background scanner"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    await _scanner.start()
    
    return {
        "success": True,
        "message": "Background scanner started",
        "status": _scanner.get_stats()
    }


@router.post("/stop")
async def stop_scanner():
    """Stop the background scanner"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    await _scanner.stop()
    
    return {
        "success": True,
        "message": "Background scanner stopped"
    }


@router.get("/status")
async def get_scanner_status():
    """Get current scanner status and statistics"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    return {
        "success": True,
        **_scanner.get_stats()
    }


# ===================== Alert Management =====================

@router.get("/alerts")
async def get_live_alerts(priority: Optional[str] = None):
    """
    Get current live alerts from the background scanner.
    
    These are real-time alerts generated by continuous scanning.
    Optionally filter by priority: critical, high, medium, low
    """
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    from services.enhanced_scanner import AlertPriority
    
    priority_filter = None
    if priority:
        try:
            priority_filter = AlertPriority(priority.lower())
        except ValueError:
            raise HTTPException(status_code=400, detail=f"Invalid priority: {priority}")
    
    alerts = _scanner.get_live_alerts(priority_filter)
    
    return {
        "success": True,
        "count": len(alerts),
        "alerts": [a.to_dict() for a in alerts],
        "scanner_running": _scanner._running
    }


@router.get("/alerts/{alert_id}")
async def get_alert(alert_id: str):
    """Get a specific alert by ID"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    alert = _scanner.get_alert_by_id(alert_id)
    if not alert:
        raise HTTPException(status_code=404, detail="Alert not found")
    
    return {
        "success": True,
        "alert": alert.to_dict()
    }


@router.post("/alerts/{alert_id}/dismiss")
async def dismiss_alert(alert_id: str):
    """Dismiss/acknowledge an alert"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    success = _scanner.dismiss_alert(alert_id)
    
    if not success:
        raise HTTPException(status_code=404, detail="Alert not found")
    
    return {"success": True, "message": "Alert dismissed"}


# ===================== Configuration =====================

@router.post("/watchlist")
async def set_watchlist(request: WatchlistRequest):
    """Set the symbols to scan"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    _scanner.set_watchlist(request.symbols)
    
    return {
        "success": True,
        "watchlist": [s.upper() for s in request.symbols],
        "message": f"Watchlist set to {len(request.symbols)} symbols"
    }


@router.get("/watchlist")
async def get_watchlist():
    """Get current watchlist"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    return {
        "success": True,
        "watchlist": _scanner._watchlist,
        "count": len(_scanner._watchlist)
    }


@router.post("/config")
async def update_config(request: ConfigRequest):
    """Update scanner configuration"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    if request.scan_interval:
        _scanner.set_scan_interval(request.scan_interval)
    
    if request.enabled_setups is not None:
        _scanner._enabled_setups = set(request.enabled_setups)
    
    return {
        "success": True,
        "config": {
            "scan_interval": _scanner._scan_interval,
            "enabled_setups": list(_scanner._enabled_setups)
        }
    }


@router.get("/config")
async def get_config():
    """Get current scanner configuration"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    return {
        "success": True,
        "scan_interval": _scanner._scan_interval,
        "enabled_setups": list(_scanner._enabled_setups),
        "min_scan_interval": _scanner._min_scan_interval,
        "symbols_per_batch": _scanner._symbols_per_batch,
        "min_rvol_filter": _scanner._min_rvol_filter,
        "auto_execute_enabled": _scanner._auto_execute_enabled
    }


# ===================== Strategy Stats (Win-Rate Tracking) =====================

@router.get("/stats/strategies")
async def get_strategy_stats(setup_type: Optional[str] = None):
    """Get win-rate statistics for strategies"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    stats = _scanner.get_strategy_stats(setup_type)
    
    return {
        "success": True,
        "stats": stats
    }


@router.post("/stats/record-outcome")
async def record_alert_outcome(
    alert_id: str = Query(..., description="Alert ID"),
    outcome: str = Query(..., description="Outcome: won, lost, expired, cancelled"),
    pnl: float = Query(default=0.0, description="Realized P&L")
):
    """Record the outcome of an alert for win-rate tracking"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    if outcome not in ["won", "lost", "expired", "cancelled"]:
        raise HTTPException(status_code=400, detail="Invalid outcome. Use: won, lost, expired, cancelled")
    
    _scanner.record_alert_outcome(alert_id, outcome, pnl)
    
    return {
        "success": True,
        "message": f"Recorded {outcome} for alert {alert_id}"
    }


# ===================== Auto-Execution Control =====================

@router.post("/auto-execute/enable")
async def enable_auto_execute(
    enabled: bool = Query(default=True),
    min_win_rate: float = Query(default=0.55, ge=0.0, le=1.0),
    min_priority: str = Query(default="high", regex="^(critical|high)$")
):
    """Enable or disable auto-execution of high-priority alerts"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    _scanner.enable_auto_execute(enabled, min_win_rate, min_priority)
    
    return {
        "success": True,
        "auto_execute_enabled": enabled,
        "min_win_rate": min_win_rate,
        "min_priority": min_priority
    }


@router.get("/auto-execute/status")
async def get_auto_execute_status():
    """Get auto-execution status"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    return {
        "success": True,
        "enabled": _scanner._auto_execute_enabled,
        "min_win_rate": _scanner._auto_execute_min_win_rate,
        "min_priority": _scanner._auto_execute_min_priority.value,
        "trading_bot_connected": _scanner._trading_bot is not None
    }


# ===================== RVOL Pre-filter =====================

@router.post("/config/rvol-filter")
async def set_rvol_filter(
    min_rvol: float = Query(default=0.8, ge=0.0, le=5.0, description="Minimum RVOL to scan symbol")
):
    """Set minimum RVOL filter for pre-filtering symbols"""
    if not _scanner:
        raise HTTPException(status_code=500, detail="Scanner not initialized")
    
    _scanner._min_rvol_filter = min_rvol
    
    return {
        "success": True,
        "min_rvol_filter": min_rvol,
        "message": f"Symbols with RVOL < {min_rvol} will be skipped"
    }
